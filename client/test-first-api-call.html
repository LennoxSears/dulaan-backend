<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>First API Call Test</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #00ff00;
            padding: 20px;
            line-height: 1.4;
        }
        .test-output {
            background: #000;
            border: 1px solid #333;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
            white-space: pre-wrap;
            font-size: 14px;
            max-height: 400px;
            overflow-y: auto;
        }
        .button {
            background: #333;
            color: #00ff00;
            border: 1px solid #555;
            padding: 10px 20px;
            cursor: pointer;
            margin: 10px 5px;
            border-radius: 3px;
        }
        .button:hover {
            background: #555;
        }
        .success { color: #00ff00; }
        .error { color: #ff4444; }
        .warning { color: #ffaa00; }
        .info { color: #4488ff; }
    </style>
</head>
<body>
    <div class="container">
        <h1>First API Call Test</h1>
        
        <button class="button" onclick="testFirstApiCall()">Test First API Call Logic</button>
        <button class="button" onclick="testTimeSinceLastSend()">Test timeSinceLastSend Calculation</button>
        <button class="button" onclick="clearOutput()">Clear Output</button>
        
        <div id="output" class="test-output">Ready to test first API call logic...\n</div>
    </div>

    <script src="dulaan-browser-bundled.js"></script>
    <script>
        function log(message, type = 'info') {
            const output = document.getElementById('output');
            const timestamp = new Date().toLocaleTimeString();
            const className = type;
            output.innerHTML += `<span class="${className}">[${timestamp}] ${message}</span>\n`;
            output.scrollTop = output.scrollHeight;
        }

        function clearOutput() {
            document.getElementById('output').innerHTML = 'Output cleared...\n';
        }

        function testFirstApiCall() {
            log('Testing first API call logic...', 'info');
            
            try {
                if (typeof window.StreamingProcessor !== 'undefined') {
                    const processor = new window.StreamingProcessor();
                    log(`✅ StreamingProcessor created`, 'success');
                    log(`Initial lastApiCall: ${processor.lastApiCall}`, 'info');
                    
                    // Test the timeSinceLastSend calculation for first call
                    const timeSinceLastSend = processor.lastApiCall === 0 ? 1000 : Date.now() - processor.lastApiCall;
                    log(`timeSinceLastSend for first call: ${timeSinceLastSend}ms`, 'info');
                    
                    if (timeSinceLastSend > 500) {
                        log('✅ First API call would be allowed (timeSinceLastSend > 500)', 'success');
                    } else {
                        log(`❌ First API call would be blocked (timeSinceLastSend: ${timeSinceLastSend})`, 'error');
                    }
                    
                    // Simulate setting lastApiCall after first call
                    processor.lastApiCall = Date.now();
                    log(`After first call, lastApiCall: ${processor.lastApiCall}`, 'info');
                    
                    // Test second call immediately
                    const timeSinceSecond = Date.now() - processor.lastApiCall;
                    log(`timeSinceLastSend for immediate second call: ${timeSinceSecond}ms`, 'info');
                    
                    if (timeSinceSecond > 500) {
                        log('⚠️ Second immediate call would be allowed (unexpected)', 'warning');
                    } else {
                        log('✅ Second immediate call would be blocked (expected)', 'success');
                    }
                    
                } else {
                    log('❌ StreamingProcessor class not available', 'error');
                }
                
            } catch (error) {
                log(`❌ Test error: ${error.message}`, 'error');
            }
        }

        function testTimeSinceLastSend() {
            log('Testing timeSinceLastSend calculation edge cases...', 'info');
            
            try {
                // Test with undefined lastApiCall (old behavior)
                let lastApiCall = undefined;
                let timeSinceLastSend = Date.now() - lastApiCall;
                log(`undefined - Date.now(): ${timeSinceLastSend} (should be NaN)`, 'info');
                log(`NaN > 500: ${timeSinceLastSend > 500} (should be false)`, timeSinceLastSend > 500 ? 'error' : 'success');
                
                // Test with 0 lastApiCall (new behavior)
                lastApiCall = 0;
                timeSinceLastSend = lastApiCall === 0 ? 1000 : Date.now() - lastApiCall;
                log(`0 with special handling: ${timeSinceLastSend}ms`, 'info');
                log(`1000 > 500: ${timeSinceLastSend > 500} (should be true)`, timeSinceLastSend > 500 ? 'success' : 'error');
                
                // Test with recent timestamp
                lastApiCall = Date.now() - 100; // 100ms ago
                timeSinceLastSend = lastApiCall === 0 ? 1000 : Date.now() - lastApiCall;
                log(`Recent call (100ms ago): ${timeSinceLastSend}ms`, 'info');
                log(`~100 > 500: ${timeSinceLastSend > 500} (should be false)`, timeSinceLastSend > 500 ? 'error' : 'success');
                
                // Test with old timestamp
                lastApiCall = Date.now() - 1000; // 1000ms ago
                timeSinceLastSend = lastApiCall === 0 ? 1000 : Date.now() - lastApiCall;
                log(`Old call (1000ms ago): ${timeSinceLastSend}ms`, 'info');
                log(`~1000 > 500: ${timeSinceLastSend > 500} (should be true)`, timeSinceLastSend > 500 ? 'success' : 'error');
                
                log('✅ All timeSinceLastSend calculations working correctly', 'success');
                
            } catch (error) {
                log(`❌ Test error: ${error.message}`, 'error');
            }
        }

        // Auto-run tests on load
        window.addEventListener('load', () => {
            setTimeout(() => {
                testFirstApiCall();
                setTimeout(() => testTimeSinceLastSend(), 200);
            }, 100);
        });
    </script>
</body>
</html>