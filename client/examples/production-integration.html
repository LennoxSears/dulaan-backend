<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dulaan Production Integration Example</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        .container { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 20px; }
        .code-block { background: #f8f9fa; padding: 15px; border-radius: 4px; font-family: monospace; overflow-x: auto; }
        button { background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; margin: 5px; }
        .success { color: #28a745; } .error { color: #dc3545; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸš€ Production Integration Example</h1>
        <p>Complete production-ready implementation with error handling, logging, and optimization.</p>
    </div>

    <div class="container">
        <h2>ðŸ“¦ Complete Setup</h2>
        <div class="code-block">
&lt;!-- Production HTML Setup --&gt;
&lt;script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"&gt;&lt;/script&gt;
&lt;script src="dulaan-browser.js"&gt;&lt;/script&gt;
&lt;script&gt;
// Production initialization
class DulaanApp {
    constructor() {
        this.isInitialized = false;
        this.errorHandler = new ErrorHandler();
        this.analytics = new Analytics();
    }
    
    async initialize() {
        try {
            await window.dulaan.initialize();
            this.setupErrorHandling();
            this.setupAnalytics();
            this.isInitialized = true;
            console.log('Dulaan app initialized');
        } catch (error) {
            this.errorHandler.handle('initialization', error);
        }
    }
}
&lt;/script&gt;
        </div>
        
        <button onclick="initializeApp()">Initialize Production App</button>
        <div id="status"></div>
    </div>

    <div class="container">
        <h2>ðŸ”§ Error Handling & Recovery</h2>
        <div class="code-block">
class ErrorHandler {
    constructor() {
        this.retryAttempts = new Map();
        this.maxRetries = 3;
    }
    
    async handle(operation, error) {
        const attempts = this.retryAttempts.get(operation) || 0;
        
        if (attempts < this.maxRetries) {
            this.retryAttempts.set(operation, attempts + 1);
            const delay = Math.pow(2, attempts) * 1000;
            
            setTimeout(() => this.retry(operation), delay);
        } else {
            this.reportError(operation, error);
            this.fallbackStrategy(operation);
        }
    }
}
        </div>
        
        <button onclick="testErrorHandling()">Test Error Recovery</button>
    </div>

    <div class="container">
        <h2>ðŸ“Š Analytics & Monitoring</h2>
        <div class="code-block">
class Analytics {
    constructor() {
        this.events = [];
        this.sessionId = this.generateSessionId();
    }
    
    track(event, data = {}) {
        const eventData = {
            timestamp: Date.now(),
            sessionId: this.sessionId,
            event: event,
            data: data
        };
        
        this.events.push(eventData);
        this.sendToAnalytics(eventData);
    }
    
    async sendToAnalytics(data) {
        // Send to your analytics service
        console.log('Analytics:', data);
    }
}
        </div>
        
        <button onclick="trackEvent()">Track Sample Event</button>
    </div>

    <script src="../dulaan-browser.js"></script>
    <script>
        let app = null;

        async function initializeApp() {
            try {
                app = new DulaanApp();
                await app.initialize();
                updateStatus('App initialized successfully', 'success');
            } catch (error) {
                updateStatus('Initialization failed: ' + error.message, 'error');
            }
        }

        function testErrorHandling() {
            if (app) {
                const testError = new Error('Test error for demonstration');
                app.errorHandler.handle('test_operation', testError);
                updateStatus('Error handling test triggered', 'success');
            }
        }

        function trackEvent() {
            if (app) {
                app.analytics.track('button_click', { button: 'track_event' });
                updateStatus('Event tracked', 'success');
            }
        }

        function updateStatus(message, type) {
            const status = document.getElementById('status');
            status.className = type;
            status.textContent = message;
        }

        // Production classes
        class DulaanApp {
            constructor() {
                this.isInitialized = false;
                this.errorHandler = new ErrorHandler();
                this.analytics = new Analytics();
            }
            
            async initialize() {
                try {
                    await window.dulaan.initialize();
                    this.setupErrorHandling();
                    this.setupAnalytics();
                    this.isInitialized = true;
                    this.analytics.track('app_initialized');
                } catch (error) {
                    this.errorHandler.handle('initialization', error);
                    throw error;
                }
            }
            
            setupErrorHandling() {
                window.addEventListener('error', (event) => {
                    this.errorHandler.handle('javascript_error', event.error);
                });
                
                window.addEventListener('unhandledrejection', (event) => {
                    this.errorHandler.handle('promise_rejection', event.reason);
                });
            }
            
            setupAnalytics() {
                this.analytics.track('session_start');
            }
        }

        class ErrorHandler {
            constructor() {
                this.retryAttempts = new Map();
                this.maxRetries = 3;
                this.errorLog = [];
            }
            
            async handle(operation, error) {
                this.logError(operation, error);
                
                const attempts = this.retryAttempts.get(operation) || 0;
                
                if (attempts < this.maxRetries && this.isRetryable(error)) {
                    this.retryAttempts.set(operation, attempts + 1);
                    const delay = Math.pow(2, attempts) * 1000;
                    
                    setTimeout(() => this.retry(operation), delay);
                } else {
                    this.reportError(operation, error);
                    this.fallbackStrategy(operation);
                }
            }
            
            logError(operation, error) {
                const errorEntry = {
                    timestamp: new Date().toISOString(),
                    operation: operation,
                    message: error.message,
                    stack: error.stack
                };
                
                this.errorLog.push(errorEntry);
                console.error(`[${operation}]`, error);
            }
            
            isRetryable(error) {
                const retryableErrors = ['NetworkError', 'TimeoutError', 'ConnectionError'];
                return retryableErrors.includes(error.name);
            }
            
            retry(operation) {
                console.log(`Retrying operation: ${operation}`);
                // Implement retry logic based on operation type
            }
            
            reportError(operation, error) {
                // Send error report to monitoring service
                console.log(`Reporting error for ${operation}:`, error);
            }
            
            fallbackStrategy(operation) {
                // Implement fallback strategies
                console.log(`Executing fallback for ${operation}`);
            }
        }

        class Analytics {
            constructor() {
                this.events = [];
                this.sessionId = this.generateSessionId();
                this.batchSize = 10;
                this.flushInterval = 30000; // 30 seconds
                
                this.startBatchFlush();
            }
            
            generateSessionId() {
                return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            }
            
            track(event, data = {}) {
                const eventData = {
                    timestamp: Date.now(),
                    sessionId: this.sessionId,
                    event: event,
                    data: data,
                    userAgent: navigator.userAgent,
                    url: window.location.href
                };
                
                this.events.push(eventData);
                
                if (this.events.length >= this.batchSize) {
                    this.flush();
                }
            }
            
            startBatchFlush() {
                setInterval(() => {
                    if (this.events.length > 0) {
                        this.flush();
                    }
                }, this.flushInterval);
            }
            
            async flush() {
                if (this.events.length === 0) return;
                
                const eventsToSend = [...this.events];
                this.events = [];
                
                try {
                    await this.sendToAnalytics(eventsToSend);
                } catch (error) {
                    // Re-add events if sending failed
                    this.events.unshift(...eventsToSend);
                    console.error('Failed to send analytics:', error);
                }
            }
            
            async sendToAnalytics(events) {
                // In production, send to your analytics service
                console.log('Sending analytics batch:', events);
                
                // Example: send to your analytics endpoint
                // await fetch('/api/analytics', {
                //     method: 'POST',
                //     headers: { 'Content-Type': 'application/json' },
                //     body: JSON.stringify({ events })
                // });
            }
        }
    </script>
</body>
</html>